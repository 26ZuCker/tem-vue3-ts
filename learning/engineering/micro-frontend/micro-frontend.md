## 微前端

出现原因：

1. 需要迁移遗留系统
2. 后端解耦
3. 前端聚合
4. 热闹驱动开发
5. 无关技术栈
6. 独立开发、独立部署 子应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新
7. 独立运行时 每个子应用之间状态隔离，运行时状态不共享

缺陷：

### 实现方式

> 关键需要：
>
> - 自带的样式
> - 子应用加载器（Loader）
> - 沙盒隔离（Sandbox）
> - 路由控制（Router）
> - 子应用通信（Store）

1. 前端容器化：将 iframe 作为容器来容纳其它前端应用，缺点：

   - 登录态 cookie 同步问题
   - 子应用间通信问题
   - 大量组件重复
   - url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用
   - UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..
   - 全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果
   - 慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程

2. 路由分发式：通过 HTTP 服务器的反向代理功能，将请求路由映射到对应的应用上
3. 前端微服务化：在不同的框架之上设计通信和加载机制，以在一个页面内加载对应的应用
4. 微应用：通过软件工程的方式，在部署构建环境中，把多个独立的应用组合成一个单体应用
5. 微件化：开发一个新的构建系统，将部分业务功能构建成一个独立的 chunk 代码，使用时只需要远程加载即可
6. 应用组件化：基于 Web Components 构建跨框架的前端应用

#### loader

#### router

#### sandbox

#### store

### 架构设计

- 组件和样式
- 应用间通信
  - 兄弟间
    - 全局自定义事件
    - 共享 window
  - 父子
    - PostMessage
    - 通过 parent.window 寻找父窗口后再发出全局自定义事件
    - 当其他应用加载时将消息发送给父窗口，由父窗口发出自定义事件
    - 当其他应用未加载时先将消息传递给父窗口再由父窗口进行存储，提供一个获取通信的机制
- 数据共享
  - URL 参数
  - localStorage
  - 其他客户端存储如 indexedDB 和 web sql
  - 服务端采用 json 存储客户端状态
- 构建系统

### qiankun
