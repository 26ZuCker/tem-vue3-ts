## 正则

参考：

- https://juejin.cn/post/6907143412227522567

### 字符

1. 匹配字符，以下只列举常用，注意字符`-`只适用于数字和单个字符

   | 常用匹配字符 |             **含义**             |
   | :----------: | :------------------------------: |
   |    [0-9]     |         匹配单个数字 0-9         |
   |    [a-z]     |         匹配单个小写字母         |
   |    [A-Z]     |         匹配单个大写字母         |
   |      \s      | 匹配所有空白字符，如空格、换行等 |
   |      \n      |          匹配所有换行符          |
   |      \b      |     匹配边界如字符之间的空格     |

2. 关键字符

| 特殊字符 | 含义 | 示例 |
| :-: | :-: | :-: |
| () | 表示一个子表达式分组，关于组的概念参考下方实例方法 | 匹配的子表达式可以用于以后使用 |
| ^ | 1. 匹配输入字符串的开始位置 2. 用在[]中时表示 非 | 1. `/^http/` 匹配以 http 开头的字符串 2. `/[^a-zA-Z]/` 匹配非字母 |
| \$ | 匹配输入字符串的结尾位置 | `/.com$/` 匹配以.com 结尾的字符串 |
| \| | 二选一，表示 或 | `/a|b/` 匹配 a 或者 b |
| . | 小数点匹配换行符\n 之外的任何单个字符 | `/./` 匹配换行符之外的其他字符 |
| [] | 中括号匹配一个字符 | `/[aeiou]/` 匹配字母 aeiou 中的一个 |
| {} | 大括号表示限定一个表达式多少次 | {n} 匹配 n 次; {n,} 匹配最少 n 次; {n, m} 匹配 n-m 次 |
| + | 匹配前面的子表达式一次或多次 | `/[0-9]+/` 匹配一个数字或多个数字 |
| \* | 匹配前面的子表达式零次或多次 | `/[0-9]*/` 匹配 0 次数字或多个数字 |
| ? | 1. 匹配前面的子表达式零次或一次 2. 指明一个非贪婪限定符 | 1. `/[0-9]?/` 2. `/<.*?>/` 匹配一个标签如`<p>` |

### 实例方法

能够使用的 String.prototype

```js
//正则表达式分为两种
//字面量，注意不能包含模板字符串等变量
const reg1 = /.a/g;
//构造函数
const reg2 = new RegExp('[0-9a-z]', 'g')();
const reg3 = new RegExp(`我的名字叫${name}`);

const str = '';
//测试是否符合
if (reg1.test(str)) {
  //获取匹配到的字符串
  const newStr2 = str.match(reg3); // ['11.11.11']
  //将获取匹配到的字符串替换
  const newStr1 = str.replace(reg2, 'x');
}
```

以上通过()包裹的子表达式将会被缓存为一个分组以方便后面对其引用

正则表达式中通过`\n`只引用第 n 个分组，在外通过`$n`引用第 n 个分组

```js
```

### 匹配模式

#### 贪婪

默认贪婪匹配即`*`和`+`

#### 惰性

非贪婪即在贪婪后加上`?`实现只匹配符合条件的第一段字符串

#### 模糊

### 执行原理

传统正则引擎分为 NFA 即非确定性有限状态自动机和 DFA 即确定性有限状态自动机

java 和 javascript 的正则都是 NFA

参考：

- https://juejin.cn/post/6844903889687281677
- https://es6.ruanyifeng.com/#docs/regex

#### DFA

实际就是把正则表达式转换成一个图的邻接表，然后通过跳表的形式判断一个字符串是否匹配该正则

```js
/**
 * 模拟实现
 */
function machine(input) {
  if (typeof input !== 'string') {
    console.log('输入有误');
    return;
  }
  // 比如正则：/abc/ 转换成DFA之后
  // 这里我们定义了4种状态，分别是0,1,2,3，初始状态为0
  const reg = {
    0: {
      a: 1,
    },
    1: {
      b: 3,
    },
    2: {
      isEnd: true,
    },
    3: {
      c: 2,
    },
  };
  let status = 0;
  for (let i = 0; i < input.length; i++) {
    const inputChar = input[i];
    status = reg[status][inputChar];
    if (typeof status === 'undefined') {
      console.log('匹配失败');
      return false;
    }
  }
  const end = reg[status];
  if (end && end.isEnd === true) {
    console.log('匹配成功');
    return true;
  } else {
    console.log('匹配失败');
    return false;
  }
}

const input = 'abc';
machine(input);
```

#### NFA

实际就是在语法解析的时候，构造出的一个有向图，然后通过 dfs 的方式，去一条路径一条路径的递归尝试

```js
```

### 性能优化

一般情况下正则效率优于字符串方法

由于 js 使用 NFA 则以下基于后者进行优化参考https://zhuanlan.zhihu.com/p/32896848

少写模糊匹配，越精确越好

模糊，贪婪，惰性匹配都会带来回溯问题
